

#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdio.h>                 // Библиотека для ввода-вывода
# include <readline/readline.h>     // Библиотека для работы с командной строкой
# include <readline/history.h>      // Библиотека для работы с историей команд
# include <stdbool.h>               // Библиотека для работы с логическими значениями
# include <fcntl.h>                 // Библиотека для работы с файлами (открытие, закрытие и т.д.)
# include <sys/wait.h>              // Библиотека для работы с процессами (ожидание завершения)
# include <signal.h>                // Библиотека для обработки сигналов
# include <dirent.h>                // Библиотека для работы с директориями
# include <termios.h>               // Библиотека для настройки терминала
# include <limits.h>                // Библиотека для определения пределов типов
# include "libft.h"                 // Подключение библиотеки для работы со строками и памятью
# include "tokenizing.h"            // Подключение заголовочного файла для токенизации
# include "parsing.h"               // Подключение заголовочного файла для разбора

// Структура для хранения переменных окружения
typedef struct s_env
{
	char			*key;           // Ключ переменной окружения
	char			*value;         // Значение переменной окружения
	struct s_env	*next;          // Указатель на следующий элемент в списке
}	t_env;

// Перечисление сообщений об ошибках
typedef enum e_err_msg
{
	ERRMSG_CMD_NOT_FOUND,          // Ошибка: команда не найдена
	ERRMSG_NO_SUCH_FILE,           // Ошибка: файл не найден
	ERRMSG_PERM_DENIED,            // Ошибка: доступ запрещен
	ERRMSG_AMBIGUOUS,              // Ошибка: неоднозначность
	ERRMSG_TOO_MANY_ARGS,          // Ошибка: слишком много аргументов
	ERRMSG_NUMERIC_REQUI           // Ошибка: требуется числовое значение
}	t_err_msg;

// Перечисление кодов ошибок
typedef enum e_err_no
{
	ENO_SUCCESS,                   // Успешное завершение
	ENO_GENERAL,                   // Общая ошибка
	ENO_CANT_EXEC = 126,           // Ошибка: невозможно выполнить
	ENO_NOT_FOUND,                 // Ошибка: не найдено
	ENO_EXEC_255 = 255             // Ошибка: выполнение завершено с кодом 255
}	t_err_no;

// Перечисление направлений для AST (абстрактного синтаксического дерева)
typedef enum e_ast_direction
{
	TD_LEFT,                       // Левое направление
	TD_RIGHT                       // Правое направление
}	t_ast_direction;

// Структура для хранения информации об ошибках
typedef struct s_err
{
	t_err_no	no;                 // Код ошибки
	t_err_msg	msg;                // Сообщение об ошибке
	char		*cause;             // Причина ошибки
}	t_err;

// Структура для хранения информации о пути
typedef struct s_path
{
	t_err	err;                    // Ошибка
	char	*path;                  // Путь
}	t_path;

// Основная структура для хранения состояния мини-оболочки
typedef struct s_minishell
{
	char			*line;           // Строка ввода от пользователя
	t_token			*tokens;         // Токены, полученные после токенизации
	t_token			*curr_token;     // Текущий токен
	t_node			*ast;            // Корень абстрактного синтаксического дерева
	int				exit_s;         // Код выхода
	bool			signint_child;   // Флаг для обработки сигнала SIGINT в дочерних процессах
	t_parse_err		parse_err;      // Структура для хранения ошибок разбора
	int				stdin;           // Дескриптор стандартного ввода
	int				stdout;          // Дескриптор стандартного вывода
	char			**environ;       // Массив строк окружения
	t_env			*envlst;         // Список переменных окружения
	bool			heredoc_sigint;  // Флаг для обработки сигнала SIGINT в heredoc
	struct termios	original_term;   // Настройки терминала по умолчанию
}					t_minishell;

// Глобальная переменная для хранения состояния мини-оболочки
extern t_minishell	g_minishell;

/* ****************************   BUILTINS   ****************************** */
// Объявления функций для встроенных команд (builtins)

// * cd.c ********************************************************************
// Функция для смены директории
int		ft_cd(char *path);

// * echo.c ******************************************************************
// Функция для вывода строки
int		ft_echo(char **args);

// * env_utils.c *************************************************************
// Функции для работы с переменными окружения
char	*ft_get_envlst_val(char *key);
bool	ft_env_entry_exists(char *key);
void	ft_update_envlst(char *key, char *value, bool create);

// * env.c *******************************************************************
// Функции для извлечения ключей и значений из переменных окружения
char	*ft_extract_key(char *str);
char	*ft_extract_value(char *str);
void	ft_init_envlst(void);      // Инициализация списка переменных окружения
int		ft_env(void);               // Вывод всех переменных окружения

// * exit.c ******************************************************************
// Функция для выхода из оболочки
void	ft_exit(char **args);

// * export.c ****************************************************************
// Функция для экспорта переменных окружения
int		ft_check_key(char *str);
int		ft_export(char **argv);

// * pwd.c *******************************************************************
// Функция для вывода текущей директории
int		ft_pwd(void);

// * unset.c *****************************************************************
// Функция для удаления переменной окружения
int		ft_unset(char **args);

/* ****************************   CLEANING   ****************************** */
// Функции для очистки ресурсов
// * ft_clean_ms.c ***********************************************************
void	ft_clean_ms(void);

/* ******************************   EXEC   ******************************** */
// Объявления функций для выполнения команд

// * error_msg.c *************************************************************
// Функция для обработки сообщений об ошибках
int		ft_err_msg(t_err err);

// * exec_builtin.c **********************************************************
// Функции для выполнения встроенных команд
int		ft_exec_builtin(char **args);
bool	ft_is_builtin(char *arg);

// * exec_redirect.c *********************************************************
// Функции для работы с перенаправлениями ввода-вывода
int		ft_out(t_io_node *io_list, int *status);
int		ft_in(t_io_node *io_list, int *status);
int		ft_append(t_io_node *io_list, int *status);

// * exec_utils.c ************************************************************
// Утилиты для выполнения команд
void	*ft_garbage_collector(void *ptr, bool clean);
bool	ft_is_delimiter(char *delimiter, char *str);

// * exec.c ******************************************************************
// Функции для выполнения узлов абстрактного синтаксического дерева
int		ft_get_exit_status(int status);
int		ft_exec_node(t_node *tree, bool piped);

// * exist_check.c ***********************************************************
// Функции для проверки существования файлов и команд
t_err	ft_check_exec(char *file, bool cmd);
t_err	ft_check_read(char *file);
t_err	ft_check_write(char *file);

// * ft_exec_simple_cmd.c ****************************************************
// Функции для выполнения простых команд
int		ft_check_redirection(t_node *node);
void	ft_reset_stds(bool piped);
int		ft_exec_simple_cmd(t_node *node, bool piped);

// * ft_get_path.c ***********************************************************
// Функция для получения пути к исполняемому файлу
t_path	ft_get_path(char *cmd);

// * init_tree.c *************************************************************
// Функции для инициализации абстрактного синтаксического дерева
void	ft_init_tree(t_node *node);
void	ft_heredoc(t_io_node *io, int p[2]);

/* ****************************   EXPANDER   ****************************** */
// Объявления функций для расширения переменных и шаблонов

// * ft_asterisker.c *********************************************************
bool	ft_match_star(char *pattern, char *str);

// * ft_clean_empty_strs.c ***************************************************
// Функция для очистки пустых строк
char	*ft_clean_empty_strs(char *str);

// * ft_expand_utils.c *******************************************************
// Утилиты для работы с расширением строк
bool	ft_is_valid_var_char(char c);
char	*ft_handle_normal_str(char *str, size_t *i);
char	*ft_handle_squotes(char *str, size_t *i);
char	*ft_handle_dquotes(char *str, size_t *i);

// * ft_expand.c *************************************************************
// Функция для расширения переменных в строках
char	*ft_handle_dollar(char *str, size_t *i);
char	**ft_expand(char *str);

// * ft_expander_split.c *****************************************************
// Функция для разделения строки на массив строк
char	**ft_expander_split(char const *s);

// * ft_globber_utils.c ******************************************************
// Утилиты для


t_minishell	g_minishell; // Объявление глобальной переменной структуры t_minishell, которая будет использоваться для хранения состояния минишелла

static void	ft_init_minishell(char **env) // Функция инициализации минишелла, принимает переменные окружения
{
	ft_memset(&g_minishell, 0, sizeof(t_minishell)); // Обнуляем все поля структуры g_minishell
	g_minishell.environ = env; // Сохраняем переменные окружения в структуру g_minishell
	ft_init_envlst(); // Инициализируем список переменных окружения
	g_minishell.stdin = dup(0); // Дублируем дескриптор стандартного ввода
	g_minishell.stdout = dup(1); // Дублируем дескриптор стандартного вывода
	tcgetattr(STDIN_FILENO, &g_minishell.original_term); // Сохраняем текущие настройки терминала в структуру
}

static void	ft_start_execution(void) // Функция для начала выполнения команд
{
	signal(SIGQUIT, ft_sigquit_handler); // Устанавливаем обработчик сигнала SIGQUIT
	ft_init_tree(g_minishell.ast); // Инициализируем абстрактное синтаксическое дерево (AST)
	if (g_minishell.heredoc_sigint) // Если был прерван heredoc сигналом SIGINT
	{
		ft_clear_ast(&g_minishell.ast); // Очищаем AST
		g_minishell.heredoc_sigint = false; // Сбрасываем флаг
	}
	tcsetattr(STDIN_FILENO, TCSANOW, &g_minishell.original_term); // Восстанавливаем исходные настройки терминала
	g_minishell.exit_s = ft_exec_node(g_minishell.ast, false); // Выполняем корневой узел AST и сохраняем код завершения
	ft_clear_ast(&g_minishell.ast); // Очищаем AST после выполнения команды
}

int	main(int argc, char **argv, char **env) // Главная функция программы
{
	((void)argc, (void)argv); // Игнорируем аргументы командной строки (argc и argv)
	ft_init_minishell(env); // Инициализируем минишелл с переменными окружения
	while (1) // Главный цикл программы
	{
		ft_init_signals(); // Устанавливаем обработчики сигналов
		g_minishell.line = readline(PROMPT); // Считываем строку с команды пользователя с помощью readline
		if (!g_minishell.line) // Если строка пуста (например, нажата клавиша Ctrl+D)
			(ft_clean_ms(), // Очищаем минишелл
				ft_putstr_fd("exit\n", 1), exit(g_minishell.exit_s)); // Выводим сообщение "exit" и выходим с кодом завершения
		if (g_minishell.line[0]) // Если введенная строка не пуста
			add_history(g_minishell.line); // Добавляем введенную строку в историю команд
		g_minishell.tokens = ft_tokenize(); // Разбиваем строку на токены
		if (!g_minishell.tokens) // Если токенизация не удалась
			continue ; // Переходим к следующей итерации цикла
		g_minishell.ast = ft_parse(); // Парсим токены и строим абстрактное синтаксическое дерево (AST)
		if (g_minishell.parse_err.type) // Если возникла ошибка при парсинге
		{
			ft_handle_parse_err(); // Обрабатываем ошибку парсинга
			continue ; // Переходим к следующей итерации цикла
		}
		ft_start_execution(); // Начинаем выполнение команды
	}
	ft_garbage_collector(NULL, true); // Очищаем память с помощью сборщика мусора
	return (ft_clean_ms(), g_minishell.exit_s); // Очищаем минишелл и возвращаем код завершения программы
}
t_minishell	g_minishell; // Объявление глобальной переменной структуры t_minishell, которая будет использоваться для хранения состояния минишелла

static void	ft_init_minishell(char **env) // Функция инициализации минишелла, принимает переменные окружения
{
	ft_memset(&g_minishell, 0, sizeof(t_minishell)); // Обнуляем все поля структуры g_minishell
	g_minishell.environ = env; // Сохраняем переменные окружения в структуру g_minishell
	ft_init_envlst(); // Инициализируем список переменных окружения
	g_minishell.stdin = dup(0); // Дублируем дескриптор стандартного ввода
	g_minishell.stdout = dup(1); // Дублируем дескриптор стандартного вывода
	tcgetattr(STDIN_FILENO, &g_minishell.original_term); // Сохраняем текущие настройки терминала в структуру
}

// Функция для инициализации списка переменных окружения (envlst) на основе глобальной переменной окружения
void	ft_init_envlst(void)
{
	int		i; // Индекс для обхода переменных окружения
	char	**environ; // Указатель на массив переменных окружения
	char	*key; // Переменная для хранения ключа (имени переменной)
	char	*value; // Переменная для хранения значения

	environ = g_minishell.environ; // Получаем переменные окружения из глобальной структуры minishell
	if (!environ) // Если окружение пусто, выходим из функции
		return ;
	i = 0;
	while (environ[i]) // Проходим по каждой строке переменных окружения
	{
		key = ft_extract_key(environ[i]); // Извлекаем ключ из строки переменной окружения
		value = ft_extract_value(environ[i]); // Извлекаем значение
		ft_update_envlst(key, value, true); // Обновляем список переменных окружения с ключом и значением
		i++;
	}
}

// Функция для вывода всех переменных окружения, аналог команды `env`
int	ft_env(void)
{
	t_env	*list; // Указатель на структуру, представляющую переменные окружения

	list = g_minishell.envlst; // Получаем список переменных окружения из глобальной структуры minishell
	while (list) // Проходим по всему списку
	{
		if (list->value != NULL) // Если у переменной есть значение
			printf("%s=%s\n", list->key, list->value); // Выводим переменную в формате "ключ=значение"
		list = list->next; // Переходим к следующей переменной в списке
	}
	return (ENO_SUCCESS); // Возвращаем код успешного завершения
}
/*ft_extract_key:

Функция извлекает ключ (имя переменной) из строки вида "ключ=значение".
Если символ = не найден, возвращается копия всей строки (например, если переменная не имеет значения).
ft_extract_value:

Функция извлекает значение переменной окружения после символа =. Если = отсутствует, возвращается NULL.
ft_init_envlst:

Инициализация списка переменных окружения. Функция проходит по каждой переменной окружения и извлекает ключ и значение, затем обновляет список переменных через ft_update_envlst.
ft_env:

Функция выводит все переменные окружения (ключ и значение), аналог команды env в Unix-подобных системах. Она проходит по списку переменных окружения и выводит их, если у переменной есть значение.*/
// Функция для обновления значения переменной окружения по ключу
void	ft_update_envlst(char *key, char *value, bool create)
{
	t_env	*envlst; // Указатель на список переменных окружения

	envlst = g_minishell.envlst; // Получаем доступ к глобальному списку
	while (envlst) // Проходим по списку
	{
		if (!ft_strcmp(key, envlst->key)) // Если найдено совпадение ключа
		{
			if (value) // Если новое значение не NULL
				envlst->value = ft_garbage_collector(ft_strdup(value), false); // Обновляем значение
			return ; // Завершаем функцию
		}
		envlst = envlst->next; // Переходим к следующему элементу
	}
	if (create) // Если create установлен в true и ключ не найден
		ft_envlst_back(ft_envlst_new(key, value)); // Создаем и добавляем новую запись
}


// Функция для извлечения ключа (имени переменной окружения) из строки вида "ключ=значение"
char	*ft_extract_key(char *str)
{
	size_t	i; // Индекс для обхода строки

	i = 0;
	while (str[i]) // Проходим по символам строки до конца
	{
		if (str[i] == '=') // Если найден символ '=', то это конец ключа
			return (ft_garbage_collector(ft_substr(str, 0, i), false)); // Возвращаем подстроку до символа '=' и сохраняем через сборщик мусора
		i++;
	}
	return (ft_strdup(str)); // Если символ '=' не найден, возвращаем копию всей строки как ключ (на случай, если переменная окружения без значения)
}

// Функция для извлечения значения (значения переменной окружения) из строки вида "ключ=значение"
char	*ft_extract_value(char *str)
{
	size_t	i; // Индекс для обхода строки

	i = 0;
	while (str[i]) // Проходим по символам строки до конца
	{
		if (str[i] == '=') // Если найден символ '=', то значение начинается после него
		{
			i++; // Переходим к первому символу значения
			return (ft_garbage_collector(
					ft_substr(str, i, ft_strlen(str) - i), false)); // Возвращаем подстроку после '=', также через сборщик мусора
		}
		i++;
	}
	return (NULL); // Если символ '=' не найден, возвращаем NULL, так как значения нет
}
// Обработчик сигнала SIGINT (обычно вызывается при нажатии Ctrl+C)
// Обрабатывает поведение в зависимости от того, находится ли программа в дочернем процессе или нет.
static void ft_sigint_handler(int num)
{
    (void)num;  // Игнорируем аргумент num, так как он не используется
    if (g_minishell.signint_child)  // Проверяем, находится ли оболочка в дочернем процессе
    {
        ft_putstr_fd("\n", 1);  // Если да, выводим новую строку
        g_minishell.signint_child = false;  // Сбрасываем флаг дочернего процесса
        g_minishell.heredoc_sigint = true;   // Устанавливаем флаг для обработки heredoc
    }
    else  // Если это не дочерний процесс
    {
        ft_putstr_fd("\n", 1);  // Выводим новую строку
        rl_replace_line("", 0); // Очищаем текущую строку ввода
        rl_on_new_line();       // Переходим на новую строку
        rl_redisplay();         // Обновляем отображение командной строки
    }
}

// Обработчик сигнала SIGQUIT
// Выводит сообщение о завершении с кодом 3.
void ft_sigquit_handler(int num)
{
    (void)num;  // Игнорируем аргумент num
    ft_putstr_fd("Quit: 3\n", 1);  // Выводим сообщение о завершении с кодом 3
}

// Инициализация обработки сигналов для оболочки
// Настраивает терминал и устанавливает обработчики для сигналов SIGINT и SIGQUIT.
void ft_init_signals(void)
{
    struct termios term;  // Объявляем переменную для хранения настроек терминала

    term = g_minishell.original_term;  // Получаем оригинальные настройки терминала
    term.c_lflag &= ~ECHOCTL;          // Отключаем вывод управляющих символов (например, Ctrl+C)
    tcsetattr(STDIN_FILENO, TCSANOW, &term); // Применяем изменённые настройки к терминалу

    g_minishell.heredoc_sigint = false; // Сбрасываем флаг для сигнала прерывания в heredoc
    g_minishell.signint_child = false;   // Сбрасываем флаг, указывающий на дочерний процесс

    signal(SIGINT, ft_sigint_handler);   // Устанавливаем обработчик для сигнала SIGINT
    signal(SIGQUIT, SIG_IGN);            // Игнорируем сигнал SIGQUIT
}


// Функция для очистки списка переменных окружения, освобождая всю выделенную память
static void ft_clear_envlst(void)
{
    t_env *envlst;              // Указатель на текущий элемент списка переменных окружения
    t_env *envlst_tofree;      // Указатель для хранения элемента, который будет освобожден

    envlst = g_minishell.envlst; // Получаем указатель на список переменных окружения из глобальной структуры
    while (envlst)              // Пока есть элементы в списке
    {
        envlst_tofree = envlst; // Сохраняем указатель на текущий элемент для освобождения
        envlst = envlst->next;  // Переходим к следующему элементу списка
        free(envlst_tofree);    // Освобождаем память, занимаемую текущим элементом
    }
    g_minishell.envlst = NULL;  // Обнуляем указатель на список окружения, чтобы избежать доступа к освобожденной памяти
}

// Функция для очистки ресурсов, связанных с минишеллом, включая AST, переменные окружения и историю команд
void ft_clean_ms(void)
{
    ft_garbage_collector(NULL, true); // Вызываем сборщик мусора для освобождения ненужной памяти
    ft_clear_ast(&g_minishell.ast);   // Очищаем абстрактное синтаксическое дерево (AST), созданное в процессе разбора
    ft_clear_envlst();                 // Очищаем список переменных окружения, освобождая память
    rl_clear_history();                // Очищаем историю команд, хранящуюся в библиотеке readline
    tcsetattr(STDIN_FILENO, TCSANOW, &g_minishell.original_term); // Восстанавливаем оригинальные настройки терминала
}

// Функция для токенизации входной строки командной оболочки.
// Она обрабатывает текущую строку команд, создаёт список токенов
// и освобождает память, занимаемую исходной строкой.
t_token *ft_tokenize(void)
{
    char *line;                // Указатель на строку, содержащую ввод пользователя.
    t_token *token_list;      // Указатель на список токенов, который будет возвращён.

    line = g_minishell.line;  // Сохраняем текущую строку из глобальной структуры g_minishell.
    token_list = ft_tokenization_handler(line);  // Вызываем обработчик токенов для токенизации строки.
    
    free(line);               // Освобождаем память, занятую исходной строкой, так как она больше не нужна.
    g_minishell.line = NULL;  // Обнуляем указатель на строку в глобальной структуре для безопасности.
    
    return (token_list);      // Возвращаем созданный список токенов.
}

// Обрабатывает разделители в строке командной оболочки.
// Если находит разделитель, добавляет его в список токенов и
// возвращает 1, если разделитель был успешно добавлен.
int ft_handle_separator(char **line_ptr, t_token **token_list)
{
    // Проверяет, является ли текущая часть строки "<<" и добавляет токен.
    if (!ft_strncmp(*line_ptr, "<<", 2))
        return (ft_append_separator(T_DLESS, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки ">>" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, ">>", 2))
        return (ft_append_separator(T_DGREAT, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки "<" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, "<", 1))
        return (ft_append_separator(T_LESS, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки ">" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, ">", 1))
        return (ft_append_separator(T_GREAT, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки "(" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, "(", 1))
        return (ft_append_separator(T_O_PARENT, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки ")" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, ")", 1))
        return (ft_append_separator(T_C_PARENT, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки "&&" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, "&&", 2))
        return (ft_append_separator(T_AND, line_ptr, token_list) && 1);
    // Проверяет, является ли текущая часть строки "||" и добавляет токен.
    else if (!ft_strncmp(*line_ptr, "||", 2))
        return (ft_append_separator(T_OR, line_ptr, token_list) && 1);
    // В противном случае, предполагает, что это "pipe" и добавляет токен.
    else
        return (ft_append_separator(T_PIPE, line_ptr, token_list) && 1);
}

// Обрабатывает строку командной оболочки, разбивая её на токены.
// Возвращает список токенов или NULL в случае ошибки.
t_token *ft_tokenization_handler(char *line)
{
    int error;             // Переменная для отслеживания ошибок токенизации.
    t_token *token_list;  // Указатель на список токенов.

    error = 0;            // Изначально ошибок нет.
    token_list = NULL;    // Изначально список токенов пуст.

    // Цикл, пока не достигнут конец строки.
    while (*line)
    {
        // Если произошла ошибка, очищает список токенов и возвращает NULL.
        if (error)
            return (ft_clear_token_list(&token_list), NULL);

        // Пропускает пробелы.
        if (ft_isspace(*line))
            ft_skip_spaces(&line);
        // Обрабатывает разделители, если текущий символ является одним из них.
        else if (!ft_strncmp(line, "<", 1) || !ft_strncmp(line, ">", 1)
              || !ft_strncmp(line, "|", 1) || !ft_strncmp(line, "&&", 2)
              || !ft_strncmp(line, "(", 1) || !ft_strncmp(line, ")", 1))
            error = (!ft_handle_separator(&line, &token_list) && 1);
        // Если символ не является разделителем, добавляет идентификатор.
        else
            error = (!ft_append_identifier(&line, &token_list) && 1);
    }

    return (token_list);  // Возвращает созданный список токенов.
}
/*Функция ft_handle_separator: Эта функция отвечает за обработку разделителей (таких как <<, >>, <, >, (, ), &&, ||, |) в строке командной оболочки. Если находит разделитель, вызывает ft_append_separator, чтобы добавить соответствующий токен в список токенов, и возвращает 1, если токен был успешно добавлен.

Функция ft_tokenization_handler: Эта функция отвечает за токенизацию строки командной оболочки. Она разбивает строку на токены, обрабатывая разделители и идентификаторы. Использует цикл для обработки каждого символа строки, пропускает пробелы, обрабатывает разделители с помощью ft_handle_separator, и добавляет идентификаторы с помощью ft_append_identifier. Если возникает ошибка, очищает список токенов и возвращает NULL. В конце возвращает список токенов.

Основные шаги в функциях:
Обработка разделителей: ft_handle_separator обрабатывает конкретные символы и добавляет их в список токенов.
Токенизация строки: ft_tokenization_handler использует цикл для обработки строки и управления ошибками, создавая токены по мере необходимости.*/
// Создает новый токен с заданным значением и типом.
// Возвращает указатель на созданный токен или NULL в случае ошибки.
t_token *ft_new_token(char *value, t_token_type type)
{
    t_token *new_token; // Указатель на новый токен.

    // Выделяет память для нового токена.
    new_token = (t_token *)ft_calloc(1, sizeof(t_token));
    // Проверяет, была ли выделена память.
    if (!new_token)
        return (NULL);
    new_token->value = value; // Устанавливает значение токена.
    new_token->type = type;    // Устанавливает тип токена.
    return (new_token);         // Возвращает созданный токен.
}

// Добавляет новый токен в конец списка токенов.
// Если список пуст, новый токен становится первым элементом списка.
void ft_token_list_add_back(t_token **lst, t_token *new_token)
{
    t_token *curr_node; // Указатель на текущий узел списка.

    // Если список пуст, добавляет новый токен как первый элемент.
    if (!*lst)
    {
        *lst = new_token;
        return ;
    }
    curr_node = *lst;
    // Находит последний элемент списка.
    while (curr_node && curr_node->next)
        curr_node = curr_node->next;
    // Добавляет новый токен в конец списка.
    curr_node->next = new_token;
    new_token->prev = curr_node; // Устанавливает обратный указатель.
}

// Очищает список токенов, освобождая выделенную память.
// Устанавливает указатель на список в NULL после очистки.
void ft_clear_token_list(t_token **lst)
{
    t_token *curr_node; // Указатель на текущий узел списка.
    t_token *next;      // Указатель на следующий узел списка.

    curr_node = *lst; // Начинает с первого узла списка.
    if (!curr_node)   // Если список пуст, просто выходим.
        return ;
    // Проходим по списку и освобождаем память.
    while (curr_node)
    {
        free(curr_node->value); // Освобождает память для значения токена.
        next = curr_node->next;  // Сохраняет указатель на следующий узел.
        free(curr_node);         // Освобождает текущий узел.
        curr_node = next;        // Переходит к следующему узлу.
    }
    *lst = NULL; // Устанавливает указатель на список в NULL.
}
/*Описание кода
Функция ft_new_token:

Эта функция создаёт новый токен, выделяя для него память.
Устанавливает его значение и тип, затем возвращает указатель на новый токен.
Если не удается выделить память, возвращает NULL.
Функция ft_token_list_add_back:

Эта функция добавляет новый токен в конец списка токенов.
Если список пуст, новый токен становится первым элементом.
В противном случае, функция находит последний элемент списка и добавляет новый токен после него, обновляя обратный указатель нового токена.
Функция ft_clear_token_list:

Эта функция очищает список токенов, освобождая память для каждого токена и его значения.
После очистки устанавливает указатель на список в NULL, что предотвращает дальнейший доступ к освобождённой памяти.
Основные шаги в функциях:
Создание токена: ft_new_token выделяет память и инициализирует новый токен.
Добавление токена: ft_token_list_add_back добавляет токен в конец списка.
Очистка списка: ft_clear_token_list освобождает память для всех элементов списка.*/

{
	if (c == '\t' || c == '\n' || c == '\v'
		|| c == '\f' || c == '\r' || c == ' ')
		return (1);
	return (0);
}
// Функция для проверки, является ли символ кавычкой.
int ft_is_quote(char c)
{
    // Если символ — одинарная или двойная кавычка, вернуть 1 (истина).
    if (c == '\'' || c == '"')
        return (1);
    return (0); // В противном случае вернуть 0 (ложь).
}

// Функция для проверки, является ли строка разделителем.
int ft_is_separator(char *s)
{
    // Проверяем, является ли строка разделителем (логические операторы, пробелы, табуляции и т.д.)
    if (!ft_strncmp(s, "&&", 2) || *s == ' ' || *s == '\t'
        || *s == '<' || *s == '>' || *s == '|' || *s == '(' || *s == ')')
        return (1); // Если это так, вернуть 1 (истина).
    return (0); // В противном случае вернуть 0 (ложь).
}

// Функция для пропуска пробелов в строке.
void ft_skip_spaces(char **line)
{
    // Пока текущий символ является пробелом или табуляцией, увеличиваем указатель на строку.
    while (**line && ft_isspace(**line))
        (*line)++;
}

// Функция для пропуска текста в кавычках.
bool ft_skip_quotes(char *line, size_t *i)
{
    char quote;

    // Сохраняем символ кавычки (одинарная или двойная).
    quote = line[*i];
    // Если находим соответствующую кавычку в строке, продолжаем.
    if (ft_strchr(line + *i + 1, quote))
    {
        (*i)++; // Переходим к следующему символу.
        // Пропускаем все символы до закрывающей кавычки.
        while (line[*i] != quote)
            (*i)++;
        (*i)++; // Пропускаем закрывающую кавычку.
        return (true); // Возвращаем истину, если кавычки были найдены.
    }
    return (false); // Возвращаем ложь, если соответствующая кавычка не найдена.
}

// Функция для печати сообщения об ошибке, когда отсутствует соответствующая кавычка.
void ft_print_quote_err(char c)
{
    // Выводим сообщение об ошибке на стандартный поток ошибок (2).
    ft_putstr_fd("minishell: unexpected EOF while looking for matching `", 2);
    ft_putchar_fd(c, 2); // Выводим символ, который вызвал ошибку.
    ft_putstr_fd("'\n", 2);
    g_minishell.exit_s = 258; // Устанавливаем код завершения для выхода из минишелла.
}
/*ft_is_quote: Проверяет, является ли переданный символ одинарной или двойной кавычкой. Возвращает 1 (истина), если это так, и 0 (ложь) в противном случае.

ft_is_separator: Проверяет, является ли переданная строка разделителем. Это включает логические операторы (&&), пробелы, табуляции и другие символы, такие как <, >, |, (, ). Возвращает 1, если строка является разделителем, и 0 в противном случае.

ft_skip_spaces: Пропускает пробелы и табуляции в строке, увеличивая указатель на строку, пока текущий символ является пробелом или табуляцией.

ft_skip_quotes: Пропускает текст, заключенный в кавычки. Проверяет наличие закрывающей кавычки после открывающей. Если соответствующая кавычка найдена, увеличивает индекс и пропускает символы до закрывающей кавычки. Возвращает true, если кавычки найдены, и false, если нет.

ft_print_quote_err: Выводит сообщение об ошибке, когда не хватает соответствующей кавычки. Устанавливает код выхода 258 в глобальной переменной g_minishell.exit_s.*/

// Добавляет разделитель (например, оператор или символ) в список токенов.
// type - тип разделителя, line_ptr - указатель на строку, token_list - указатель на список токенов.
// Возвращает 1 в случае успеха и 0 в случае ошибки.
int ft_append_separator(t_token_type type, char **line_ptr, t_token **token_list)
{
    t_token *token; // Указатель на новый токен.

    // Создает новый токен типа разделитель.
    token = ft_new_token(NULL, type);
    // Проверяет, была ли выделена память для нового токена.
    if (!token)
        return (0); // Возвращает 0 в случае ошибки.
    
    // Добавляет токен в список токенов.
    ft_token_list_add_back(token_list, token);
    
    (*line_ptr)++; // Перемещает указатель строки на следующий символ.
    
    // Если тип токена требует дополнительного сдвига указателя, увеличивает его ещё на 1.
    if (type == T_DLESS || type == T_DGREAT || type == T_OR || type == T_AND)
        (*line_ptr)++;
    
    return (1); // Возвращает 1, указывая на успех.
}

// Добавляет идентификатор (например, имя команды) в список токенов.
// line_ptr - указатель на строку, token_list - указатель на список токенов.
// Возвращает 1 в случае успеха и 0 в случае ошибки.
int ft_append_identifier(char **line_ptr, t_token **token_list)
{
    char *tmp_line; // Указатель на текущую строку.
    char *value;    // Указатель на значение токена.
    t_token *token; // Указатель на новый токен.
    size_t i;       // Индекс для прохода по строке.

    tmp_line = *line_ptr; // Сохраняет текущее значение указателя на строку.
    i = 0; // Инициализирует индекс.

    // Проходит по строке, пока не встретит разделитель.
    while (tmp_line[i] && !ft_is_separator(tmp_line + i))
    {
        // Проверяет, является ли текущий символ кавычкой.
        if (ft_is_quote(tmp_line[i]))
        {
            // Пропускает кавычки, увеличивая индекс.
            if (!ft_skip_quotes(tmp_line, &i))
                return (ft_print_quote_err(tmp_line[i]), 0); // Возвращает ошибку, если не удалось пропустить кавычки.
        }
        else
            i++; // Увеличивает индекс, если текущий символ не кавычка.
    }

    // Извлекает подстроку, представляющую идентификатор.
    value = ft_substr(tmp_line, 0, i);
    if (!value)
        return (0); // Возвращает 0 в случае ошибки.

    // Создает новый токен типа идентификатор.
    token = ft_new_token(value, T_IDENTIFIER);
    if (!token)
        return (free(value), 0); // Освобождает выделенную память и возвращает 0 в случае ошибки.

    *line_ptr += i; // Сдвигает указатель на строку на длину идентификатора.
    return (ft_token_list_add_back(token_list, token), 1); // Добавляет токен в список и возвращает 1 для успеха.
}
/*Описание функций
Функция ft_append_separator:

Цель: Добавить токен-разделитель в список токенов.
Аргументы:
type: Тип разделителя (например, оператор, символ).
line_ptr: Указатель на текущую позицию в строке.
token_list: Указатель на список токенов.
Возвращаемое значение: 1 при успешном добавлении токена или 0 при ошибке.
Процесс:
Создает новый токен заданного типа.
Добавляет его в список токенов.
Перемещает указатель строки на следующий символ, а если токен требует дополнительного сдвига, перемещает его еще раз.
Функция ft_append_identifier:

Цель: Добавить токен-идентификатор в список токенов.
Аргументы:
line_ptr: Указатель на текущую позицию в строке.
token_list: Указатель на список токенов.
Возвращаемое значение: 1 при успешном добавлении токена или 0 при ошибке.
Процесс:
Проходит по строке, пока не встретит разделитель, пропуская кавычки.
Извлекает подстроку и создает новый токен с типом идентификатора.
Сдвигает указатель строки на длину идентификатора и добавляет токен в список токенов.
Основные шаги в функциях:
Создание токена: ft_new_token используется для создания нового токена.
Добавление в список: ft_token_list_add_back добавляет токен в конец списка.
Обработка строки: обе функции сдвигают указатель на строку для правильного парсинга.
Ошибка обработки: функции обрабатывают возможные ошибки, такие как отсутствие выделенной памяти или неправильное использование кавычек.*/